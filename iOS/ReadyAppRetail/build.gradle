defaultTasks 'milhelp'
apply from: 'helper.gradle'
ant.importBuild 'RemoteBuildAndDeploy_DST.xml'


def user_home = java.lang.System.getenv("HOME")
//Project specific variables
def productName = getSystemValue("PRODUCT_NAME", "ReadyAppRetail")
def xcodeProject = getSystemValue("XCODE_PROJECT", "ReadyAppRetail.xcodeproj")
def xcodeworkspace = getWorkspaceDir(getCurrentAbsolutePath())
//NOTE THAT THIS PROVISIONING PROFILE DIR IS FOR THE BUILD MACHINE (MAC MINI). IF YOU CHANGE TO BUILD LOCALLY....DO NOT CHECK THE CHANGES IN!!!
def profiles = getAllFiles("../..", 'IBM_Mobile_First', ".mobileprovision", true)
def provProfile = getMobileFirstProvProfile()//profiles.size() == 1 ? profiles.get(0).getAbsolutePath() : ''//getSystemValue("PROVISIONING_PROFILE",  '')
println "*****Using provisioning profile: ${provProfile}"
def signer = getSystemValue("CODE_SIGNER", 'iPhone Distribution: Charles Norman (W4BUTESPCK)')
def sdk = getSystemValue('IOS_SDK', "iphoneos")
def infoPlist = getSystemValue('INFO_PLIST', "Info.plist")
def depTarget = getSystemValue('IOS_DEPLOYMENT_TARGET', "8.1")
def scheme = getScheme(getCurrentAbsolutePath())
def fail = getSystemValue('FAIL', "false")
def userPass = getSystemValue('USERPASS', 'foobar')
def signEnterprise = getSystemValue("SIGN_ENTERPRISE", "true")
def uiTestDir = getSystemValue("UI_TESTS_DIR", "UITests")
def bexcodever = getSystemValue("BE_XCODE_VERSION","default")
def signingProfile = getSystemValue("BE_SIGN_PROFILE", 'default')
def clangReportsRoot = getSystemValue("CLANG_REPORT_ROOT", projectDir.getAbsolutePath())
def appCenter = getSystemValue("APP_CENTER", "IBM_EXTERNAL_DST_APPCENTER_2")
def appCenterDesc = getSystemValue("APP_CENTER_DESCRIPTION", "${productName} application - MIL")

/*
 * Currenlty valid iOS Simulators (xcode 6.0.1)
 * iPad2-iOS7.1,iPad2-iOS8.0,iPadAir-iOS7.1,iPadAir-iOS8.0,iPadRetina-iOS7.1,iPadRetina-iOS8.0,iPhone4s-iOS7.1,iPhone4s-iOS8.0,iPhone5-iOS7.1,iPhone5-iOS8.,iPhone5s-iOS7.1,iPhone5s-iOS8.0,iPhone6-iOS8.0,iPhone6Plus-iOS8.0
 */
def simulators = getSystemValue("SIMULATORS", "iPhone6-iOS8.1,iPhone6Plus-iOS8.1")

/************************************************************************************************************
 * SHOULD NOT NEED TO MODIFY ANYTHING BELOW THIS LINE
 *************************************************************************************************************/

//Setup the BUILDID project property...ideally should be generated by Jenkins and passed in as a system property
def bldid = getBuildID('BUILDID', project)
def trgt = new File(java.lang.System.getenv("HOME") + "/builds/ios/" + project.name + "/" + bldid)
trgt = new File(getSystemValue('BUILD_DIR', trgt.getAbsolutePath()) + "/" + project.name)
def myblddir = new File( trgt.getAbsolutePath() + "/objs")
if (!trgt.isDirectory()) {
	trgt.mkdirs()
}
if (!myblddir.isDirectory()) {
	myblddir.mkdirs()
}
def junitXml = new File(trgt.getAbsolutePath() + "/junitXml")
if (!junitXml.isDirectory()) {
	junitXml.mkdirs()
}
project['buildDir'] = myblddir
project.buildDir = myblddir
project.ext.set('ROOT_BUILD_DIR', trgt)
project.ext.set('UI_TESTS_DIR', uiTestDir)
project.ext.set('PRODUCT_NAME', productName)
project.ext.set('XCODE_PROJECT', xcodeProject)
project.ext.set('PROVISIONING_PROFILE', provProfile)
project.ext.set('CODE_SIGNER', signer)
project.ext.set("IOS_SDK", sdk)
project.ext.set('INFO_PLIST', infoPlist)
project.ext.set('IOS_DEPLOYMENT_TARGET', depTarget)
project.ext.set('SCHEME', scheme)
project.ext.set('USERPASS', userPass)
project.ext.set('XCODE_WORKSPACE', xcodeworkspace)
project.ext.set("SIGN_ENTERPRISE", signEnterprise)
project.ext.set("JUNIT_XML_DIR", junitXml)
project.ext.set("SIMULATORS", simulators.split(","))
project.ext.set("BE_XCODE_VERSION", bexcodever)
project.ext.set("SIGNING_PROFILE_IOS", signingProfile)
project.ext.set("CLANG_REPORT_ROOT", clangReportsRoot)
project.ext.set("APP_CENTER", appCenter)
project.ext.set("APP_CENTER_DESCRIPTION", appCenterDesc)

buildscript {
	repositories {
		maven {
			url('http://openbakery.org/repository/')
		}
		mavenCentral()
	}
	dependencies {
		classpath group: 'org.openbakery', name: 'xcodePlugin', version: '0.9.13'
	}
}

apply plugin: 'xcode'

xcodebuild {
	//We setup all the attributes for this task in the setCommon, setdebug and setrelease tasks.

}

task getBuildNumber << {
    ext.env = java.lang.System.getenv()
    ext.buildNumber = env.BUILD_NUMBER?.toInteger()
    println "Build Number: $buildNumber"
}

task setCommon << {
	clean.execute()
	preppod()
	if (!trgt.isDirectory()) {
		def rtrn = trgt.mkdirs()
	}
	def wkspceFile = new File(XCODE_WORKSPACE)
	if (!isEmptyOrNull(XCODE_WORKSPACE) && wkspceFile.isDirectory()) {
		project['xcodebuild'].workspace = XCODE_WORKSPACE
		project['xcodebuild'].scheme = SCHEME
	} else {
		project['xcodebuild'].target = productName
		project['xcodebuild'].ext.set('xcodeProject', xcodeProject)
	}
	//project['xcodebuild'].xcodeProject = xcodeProject
	project['xcodebuild'].objRoot = project.buildDir
	project['xcodebuild'].dstRoot = project.buildDir
	project['xcodebuild'].symRoot = project.buildDir
	project['xcodebuild'].infoPlist = productName + '/' + infoPlist
	if (isHybrid()) {
		prepCordova()
	}
}

task setdebug (dependsOn: 'setCommon') << {
	project['xcodebuild'].configuration = 'Debug'
	project['xcodebuild'].sdk = 'iphonesimulator'// + IOS_DEPLOYMENT_TARGET
	project['xcodebuild'].arch = 'i386'
	project['xcodebuild'].additionalParameters = ' VALID_ARCHS=i386 TARGETED_DEVICE_FAMILY=1,2'
//	project['xcodebuild'].additionalParameters = ' VALID_ARCHS=i386'
}

task settest () << {
	preppod()
	def out = runCmd(['xcodebuild','-version'])
	def simTypeName = ''
	if (IOS_DEPLOYMENT_TARGET.contains('8')) {
		simTypeName = 'iPhone 6'
	} else if (IOS_DEPLOYMENT_TARGET.contains('7')) {
		simTypeName = 'iPhone 5'
	}
	if (out.contains("Xcode 5")) {
		if (IOS_DEPLOYMENT_TARGET.contains('8')) {
			simTypeName = 'iPhone 5s'
		} else if (IOS_DEPLOYMENT_TARGET.contains('7')) {
			simTypeName = 'iPhone Retina (3.5-inch)'
		}
	}
	xcodebuild {
		destination {
			platform = 'iOS Simulator'
			name = simTypeName
			os= IOS_DEPLOYMENT_TARGET
		}
	}
	project['xcodebuild'].scheme = SCHEME
}

task setrelease (dependsOn: 'setCommon') << {
	project['xcodebuild'].configuration = 'Release'
	project['xcodebuild'].sdk = sdk
	project['xcodebuild'].signing.keychain = signer
	project['xcodebuild'].signing.mobileProvisionURI = new File(provProfile).toURI()
	
	//before we build, lets try to make sure we don't get prompted for a password
	unlockKeychain() 
}

task iosrelease (dependsOn: ['clean','setrelease']) << {
	if ("true".equalsIgnoreCase(SIGN_ENTERPRISE)) {
		signInternal()
	} else {
		runTask(project, 'xcodebuild')
		def output = project.buildDir.getAbsolutePath() + "/xcodebuild-output.txt"
		encodeFileForEmail(output, ROOT_BUILD_DIR.getAbsolutePath(), 'buildresults.txt')
		packageiOSApp(productName, sdk)
	}
}

task iosdebug (dependsOn: ['clean','setdebug', 'xcodebuild']) << {
	def output = project.buildDir.getAbsolutePath() + "/xcodebuild-output.txt"
	encodeFileForEmail(output, ROOT_BUILD_DIR.getAbsolutePath(), 'buildresults.txt')
	println ""
	println "************************************************************"
	println "Created .app direcory in " + project.buildDir + "/Debug-iphonesimulator/"
	println "************************************************************"
}


void preppod()  {
	def podfile = new File("Podfile")
	def podlock = new File("Podfile.lock")
	if (podfile.isFile() && !podlock.isFile()) {
		def cmd = ['pod', 'install']
		runCmd(cmd)
	}
}

task iostest(dependsOn: ['iosdebug', 'settest', 'ocunittest', 'instrumentstest','hybridtest']) << {
	println ""
	println "************************************************************"
	println "Completed test execution."
	println "************************************************************"
}

String getSimName(sim, shortName=false) {
	def map = null
	if (map == null) {
		map = new HashMap<String, String>()
		/*
		 * These are the ones that should be passed in on the command line.
		 * iPad2-iOS7.1,iPad2-iOS8.0,iPadAir-iOS7.1,iPadAir-iOS8.0,iPadRetina-iOS7.1,iPadRetina-iOS8.0,iPhone4s-iOS7.1,iPhone4s-iOS8.0,iPhone5-iOS7.1,iPhone5-iOS8.,iPhone5s-iOS7.1,iPhone5s-iOS8.0,iPhone6-iOS8.0,iPhone6Plus-iOS8.0
		 */
		
		//Xcode 6 simulators
		map.put("iPad 2 (7.1 Simulator)",        "iPad2-iOS7.1")
		map.put("iPad 2 (8.0 Simulator)",        "iPad2-iOS8.0")
		map.put("iPad Air (7.1 Simulator)",      "iPadAir-iOS7.1")
		map.put("iPad Air (8.0 Simulator)",      "iPadAir-iOS8.0")
		map.put("iPad Retina (7.1 Simulator)",   "iPadRetina-iOS7.1")
		map.put("iPad Retina (8.0 Simulator)",   "iPadRetina-iOS8.0")
		map.put("iPhone 4s (7.1 Simulator)",     "iPhone4s-iOS7.1")
		map.put("iPhone 4s (8.0 Simulator)",     "iPhone4s-iOS8.0")
		map.put("iPhone 5 (7.1 Simulator)",      "iPhone5-iOS7.1")
		map.put("iPhone 5 (8.0 Simulator)",      "iPhone5-iOS8.0")
		map.put("iPhone 5s (7.1 Simulator)",     "iPhone5s-iOS7.1")
		map.put("iPhone 5s (8.0 Simulator)",     "iPhone5s-iOS8.0")
		map.put("iPhone 6 (8.0 Simulator)",      "iPhone6-iOS8.0")
		map.put("iPhone 6 Plus (8.0 Simulator)", "iPhone6Plus-iOS8.0")
		//Reverse lookup of Xcode 6 simulators...
		map.put("iPad2-iOS7.1",      "iPad 2 (7.1 Simulator)")
		map.put("iPad2-iOS8.0",      "iPad 2 (8.0 Simulator)")
		map.put("iPadAir-iOS7.1",    "iPad Air (7.1 Simulator)")
		map.put("iPadAir-iOS8.0",    "iPad Air (8.0 Simulator)")
		map.put("iPadRetina-iOS7.1", "iPad Retina (7.1 Simulator)")
		map.put("iPadRetina-iOS8.0", "iPad Retina (8.0 Simulator)")
		map.put("iPhone4s-iOS7.1",   "iPhone 4s (7.1 Simulator)")
		map.put("iPhone4s-iOS8.0",   "iPhone 4s (8.0 Simulator)")
		map.put("iPhone5-iOS7.1",    "iPhone 5 (7.1 Simulator)")
		map.put("iPhone5-iOS8.0",    "iPhone 5 (8.0 Simulator)")
		map.put("iPhone5s-iOS7.1",   "iPhone 5s (7.1 Simulator)")
		map.put("iPhone5s-iOS8.0",   "iPhone 5s (8.0 Simulator)")
		map.put("iPhone6-iOS8.0",     "iPhone 6 (8.0 Simulator)")
		map.put("iPhone6Plus-iOS8.0", "iPhone 6 Plus (8.0 Simulator)")

		//simulators for xcode 6.1.1
		map.put("iPhone6Plus-iOS8.1", "iPhone 6 Plus (8.1 Simulator)")
		map.put("iPhone6-iOS8.1", "iPhone 6 (8.1 Simulator)")
		map.put("iPhone5s-iOS8.1",   "iPhone 5s (8.1 Simulator)")
		map.put("iPhone5-iOS8.1",   "iPhone 5 (8.1 Simulator)")	
		map.put("iPhone4s-iOS8.1",   "iPhone 4s (8.1 Simulator)")
		map.put("iPadRetina-iOS8.1", "iPad Retina (8.1 Simulator)")
		map.put("iPadAir-iOS8.1",    "iPad Air (8.1 Simulator)")

		map.put("iPhone 6 Plus (8.1 Simulator)", "iPhone6Plus-iOS8.1")
		map.put("iPhone 6 (8.1 Simulator)", "iPhone6-iOS8.1")
		map.put("iPhone 5s (8.1 Simulator)", "iPhone5s-iOS8.1")
		map.put("iPhone 5 (8.1 Simulator)", "iPhone5-iOS8.1")	
		map.put("iPhone 4s (8.1 Simulator)", "iPhone4s-iOS8.1")
		map.put("iPad Retina (8.1 Simulator)", "iPadRetina-iOS8.1")
		map.put("iPad Air (8.1 Simulator)", "iPadAir-iOS8.1")

	}
	def ret = sim
	if ((shortName && sim.contains('Simulator')) || (!shortName && sim.contains("iOS"))) {
		//sim parameter is already a shortname, just return it and not the 
		ret = map.get(sim)
	}

	return ret
}

task hybridtest () << {
	if (isHybrid()) {
		println "testing hybird..."
	}
}

task instrumentstest () << {
	def uitests = new ArrayList<String>()
	def appDir = project.buildDir.getAbsolutePath() + "/Debug-iphonesimulator/${PRODUCT_NAME}.app"
	def rootOutDir = ROOT_BUILD_DIR.getAbsolutePath() + "/instruments/"
	def targetDirs = []
	//	if ((new Float(IOS_DEPLOYMENT_TARGET)) < 8.0) {
	//		autoTmpl = "/Applications/Xcode5.1.1.app/Contents/Applications/Instruments.app/Contents/PlugIns/AutomationInstrument.bundle/Contents/Resources/Automation.tracetemplate"
	//	}
	
	//we only run tests against debug built code, so this will always be the output directory.
	try {
		uitests = findFilesWithExtension(UI_TESTS_DIR, '.js',true)
		//basically just assuming we're running xcode 6.0.1 only as thats what build envoy is using..wanna build in the same way as they do.
		def autoTmpl = "/Applications/Xcode.app/Contents/Applications/Instruments.app/Contents/PlugIns/AutomationInstrument.xrplugin/Contents/Resources/Automation.tracetemplate"	
	} catch (Exception ex) {}

	if (uitests.size() > 0 && SIMULATORS.size() > 0) {
		//Lets run all tests on a single simulator first, then move on to the next one.
		for (def sim in SIMULATORS) {
			for (def uitest in uitests) {
				def parts = uitest.getName().split("\\.")
				def trgtDir= new File(rootOutDir + parts[0] + "-" + getSimName(sim, true))
				if (!trgtDir.isDirectory()) {
					trgtDir.mkdirs()
				}
				targetDirs.add(trgtDir.getAbsolutePath())
				
				def cmd = ['bash','-x','runAutomation.sh',getSimName(sim),appDir,uitest.getName(),
					uitest.getParentFile().getAbsolutePath(), trgtDir.getAbsolutePath()]
				runCmd(cmd)
				sleep (10000)
			}
		}
		
		//Now that we've run the tests, lets convert the output and move it the common junit output
		for (def trgtDir in targetDirs) {
			def testNameDir = new File(trgtDir)
			def plistFile = new File(trgtDir + "/Run 1/Automation Results.plist")
			if (plistFile.isFile()) {
				def trgtXml = JUNIT_XML_DIR.getAbsolutePath() + "/" + testNameDir.getName() + ".xml"
				//def cmd = ['echo',"${plistFile} is the file to be processed and into ${trgtXml}"]
				def cmd = ['./uia2junit',plistFile.getAbsolutePath(),trgtXml,testNameDir.getName().replaceAll("\\.","")]
				runCmd(cmd)
			} else {
				println "Couldn't find ${plistFile}, not converting to junit xml."
			}
		}
	} else {
		println "Found no uitests in ${UI_TESTS_DIR}, not running instruments."
	}
	
	
}

boolean isDefaultOCUnitTest() {
	def testFilesObjC = findFilesWithExtension(PRODUCT_NAME + "Tests", ".m", false)
	def testFilesSwift = findFilesWithExtension(PRODUCT_NAME + "Tests", ".swift", false)
	def testList = testFilesObjC
	if (testList.size() == 0 ) {
		testList = testFilesSwift
	}
	def result = false
	if (testList.size() == 0) {
		result = true
	} else if (testList.size() == 1) {
		//now we need to make sure its not the default test case.
		def name = PRODUCT_NAME
		if (PRODUCT_NAME.contains(' ') || PRODUCT_NAME.contains('-')) {
			//When creating the default test case, xcode always replaces spaces and dashes with an underscore
			name = PRODUCT_NAME.replaceAll(' ', '_').replaceAll('-', '_')
		}
		if (testList.get(0).getName().startsWith(name)) {
			result = true
		}
	}
	//If more than one, then we know we have tests to run.
	
	return result
}

task ocunittest (dependsOn: ['iosdebug', 'settest'])  << {
	description="Run unit tests"
	//ant.fail('hello')
	//So we only want to run ocunit tests if we have more .m files than just the default one. Lets code that up to see whats what.
	if (!isDefaultOCUnitTest()) {
		unlockKeychain()
		/*
		 * So basically don't want to fail jenkins when the tests fails...if any one test fails this returns a -1 which fails
		 * everythign else, aka no bueno.
		 */
		def msg = ''
		try {
			//Calling OCUnit test cases
			test.execute()
		}catch (Exception ex) {
			msg = ex.getMessage()
			println "failed while running tests. fail: ${fail}"
		}
	
		def output = project.buildDir.getAbsolutePath() + "/test/xcodebuild-output.txt"
		def asString = loadTextFileAsString(output, false)
		println asString
		
		//In case we falied, we need to send the log via email to everybody, so encoding it.
		encodeFileForEmail(output, ROOT_BUILD_DIR.getAbsolutePath() + "/test", 'testresults.txt', true)
		
		/**
		 * basically need to copy the xml files from their current location to their "final destination" outside the
		 * build tree so that they survive past "cleans"
		 */
		def xmlFiles = findFilesWithExtension(project.buildDir.getAbsolutePath() + "/test", '.xml', false)
		for ( def xmlFile : xmlFiles) {
			copyFile(xmlFile.getAbsolutePath(), JUNIT_XML_DIR.getAbsolutePath(), xmlFile.getName())
		}
		
		//Here's where we are creating xml files for hte code coverage metrics. This assumes gcovr is in the PATH somewhere.
		def appDir = getCodeCoverageDir(PRODUCT_NAME, '.gcno')
		def buildDir = new File (ROOT_BUILD_DIR.getAbsolutePath() + '/build')
		if (!buildDir.isDirectory()) {
			buildDir.mkdirs()
		}
		
		//In case I'm on the build machine and its there, otherwise I'll rely on it being on the system path.
		def gcovrBin = '/Users/milbuild/build-tools/gcovr-3.2/scripts/gcovr'
		def isFile = (new File(gcovrBin)).isFile()
		if (!isFile) {
			gcovrBin = 'gcovr'
		}
		
		def gcovrCmd = [gcovrBin,'-r','.','--object-directory',appDir,'--exclude','.*ExternalFrameworks.*','--exclude',
			'IBM.*','--exclude','Q4M.*','--xml','-o',buildDir.getAbsolutePath() + '/coverage.xml']
		runCmd(gcovrCmd)
		
		//And finally if we caught an exception we and we should fail we need too.
		if (fail.equalsIgnoreCase('true') && !''.equals(msg)) {
			println msg
			ant.fail(msg)
		}
	} else {
		println "Only have the default OCUnit test, skipping."
	}
}


task analyze() << {
	def clangReports = new File(CLANG_REPORT_ROOT + '/clangScanBuildReports')
	if (clangReports.isDirectory()) {
		delete (clangReports)
	}
	def cmd = ['scan-build','-k','-v','-v','-o',clangReports.getAbsolutePath(),'xcodebuild','-scheme',SCHEME,'-configuration','Debug','-sdk','iphonesimulator','clean','analyze']
	def output = ''
	try {
		output =  runCmd(cmd)
	} catch( Exception ex ) {
		
	}
	print output
}

void unlockKeychain() {
	if (!'foobar'.equals(USERPASS)) {
		if (USERPASS.contains(':')) {
			println "calling unlock keychain."
			def pass = USERPASS.split(':')[1]
			def user_home = java.lang.System.getenv("HOME")
			def cmd = ['security', 'unlock-keychain', '-p',  pass , user_home + '/Library/Keychains/login.keychain']
			runCmd(cmd, true, false, false)
		}
	}
}

//task signInternal(dependsOn: ['setdebug']) << {
void signInternal() {
	println("target: " + project.xcodebuild.target)
	
	ext.env = System.getenv()
    def buildNum = getBuildID('BUILDID', project)//env.BUILD_NUMBER?.toInteger()
    println("Build Number: " +buildNum)
	
	def newBundleId = 'com.ibm.cio.be.' + sanitizeString(PRODUCT_NAME)
	project['xcodebuild'].signing.identity  = 'iPhone Distribution: International Business Machines'
	//project.infoplist.bundleIdentifier = newBundleId
	//this tmpdir matches whats inside the RemoteBuildAndDeploy_DST.xml file, if this changes both files need changing.
	def tmpdir = new File('upload-tmp')
	def betmpdir = new File('buildenvoy_temp')
	if (tmpdir.isDirectory()) {
		println("deleting: " + tmpdir.getAbsolutePath())
		delete tmpdir.getAbsolutePath()
	}
	if (betmpdir.isDirectory()) {
		delete betmpdir.getAbsolutePath()
	}
	if (isHybrid()) {
		/*
		 * then lets copy the cordova crap into a directory where it can be read that doesn't require special flags to
		 * be passed in as we can't do that on Build Envoy.
		 */
		//For cordova projects, we need to do the following so build envoy will work
		def mybesrc = getCurrentAbsolutePath() + "/build/emulator/include"
		def mybetrgt = new File(tmpdir.getAbsolutePath() + "/build/Distribution-iphoneos/include")
		if (!mybetrgt.isDirectory()) {
				mybetrgt.mkdirs()
		}
		println "copying files for build envoy, src: ${mybesrc} , target: ${mybetrgt}"
		copyForBE(mybesrc, mybetrgt.getAbsolutePath())
		copyFile(mybesrc + "/../libCordova.a", mybetrgt.getAbsolutePath() + "/..", "libCordova.a")
	}
	//lets update the infoplist file before we start..the signing has to have a very specific project id...
	//Creating a copy of the project to upload to be signed by corporate certs.
	copyForBE(new File('.').getAbsoluteFile().getParentFile().getAbsolutePath(), tmpdir.getAbsolutePath())
	def currDir = getCurrentAbsolutePath()
	def plist = findPlistInfoFile(tmpdir.getAbsolutePath() + "/${PRODUCT_NAME}", PRODUCT_NAME, true)
	def cmd = ['/usr/libexec/PlistBuddy', '-c', 'Print :CFBundleIdentifier ',  plist]
	def bndlId = runCmd(cmd)

	/** Check if there is CFBundleVersion key in the plist */    
    def bundleNumCmd = ['/usr/libexec/PlistBuddy', '-c', 'Print :CFBundleVersion ',  plist]	
    def bundleNumber = runCmd(bundleNumCmd)
    println("info.plist CFBundleVersion: " + bundleNumber)        
    
    /** Update the CFBundleVersion to the build number */
    if (bundleNumber != null) {
        bundleNumCmd = ['/usr/libexec/PlistBuddy', '-c', 'Set :CFBundleVersion '+  buildNum,  plist]
        runCmd(bundleNumCmd)
    } else {
        bundleNumCmd = ['/usr/libexec/PlistBuddy', '-c', 'Add :CFBundleVersion string'+ buildNum,  plist]
        runCmd(bundleNumCmd)
    }  
    	
	/*
	 * Lets not mess with the bundle id if it already conforms to the Build Envoy (BE) form...if it doesnt, then lets 
	 * fix it so it can be signed by the BE tool.
	 */
	def containsBad = bndlId.contains('PRODUCT_NAME')
	println("bndlId" + bndlId + ", containsBad: " + containsBad)
	if (bndlId.startsWith("com.ibm.cio.be.") && !containsBad) {
		newBundleId = bndlId
	} else if (bndlId.startsWith("com.ibm.cio.be.") && containsBad) {
		def dollarIdx = bndlId.indexOf("PRODUCT_NAME")
		newBundleId = bndlId.substring(0,dollarIdx-2) + sanitizeString(PRODUCT_NAME)
		
		cmd = ['/usr/libexec/PlistBuddy', '-c', 'Set :CFBundleIdentifier ' + newBundleId,  plist]
		runCmd(cmd)
	} else {
		cmd = ['/usr/libexec/PlistBuddy', '-c', 'Set :CFBundleIdentifier ' + newBundleId,  plist]
		runCmd(cmd)
	}
	println("newBundleId: " + newBundleId)

	//This is bad, but hardcoding for now to get around since this file isnt shared.
	def watchkitAppPlist = findPlistInfoFile(tmpdir.getAbsolutePath() + "/Summit WatchKit App", PRODUCT_NAME, true)
	def watchkitExtensionPlist = findPlistInfoFile(tmpdir.getAbsolutePath() + "/Summit WatchKit Extension", PRODUCT_NAME, true)
	def wkappBundleId = "${newBundleId}.watchkitapp"
	def wkextensionBundleId = "${newBundleId}.watchkitextension"
	if (new File(watchkitAppPlist).isFile()) {
		cmd = ['/usr/libexec/PlistBuddy', '-c', 'Set :CFBundleIdentifier ' + wkappBundleId,  watchkitAppPlist]
		runCmd(cmd)
	}
	if (new File(watchkitExtensionPlist).isFile()) {
		cmd = ['/usr/libexec/PlistBuddy', '-c', 'Set :CFBundleIdentifier ' + wkextensionBundleId,  watchkitExtensionPlist]
		runCmd(cmd)
	}

	//Setting isDevelopment to false so MQA is enabled.
	cmd = ['/usr/libexec/PlistBuddy', '-c', 'Set :isDevelopment false',  plist]
	setDist = runCmd(cmd)
	cmd = ['/usr/libexec/PlistBuddy', '-c', 'Print :isDevelopment ',  plist]
	setDist = runCmd(cmd)
	println("isDevelopment: ${setDist}")

	//Update XtifyGlobal.h to have line for development removed
	def xtifyGlobalFile = findFilesWithExtension("upload-tmp/${PRODUCT_NAME}/ExternalLibraries","XtifyGlobal.h", true)[0]
	println ("xtifyGlobalFile: ${xtifyGlobalFile}")
	def xtifyGlobalLines = loadTextFile(xtifyGlobalFile.getAbsolutePath(), false)
	def newFile = new ArrayList<String>()
	for (def line : xtifyGlobalLines) {
		if (line.contains("define DEV 1")){
			continue
		}
		newFile.add(line)
	}
	writeFile(xtifyGlobalFile.getAbsolutePath() , newFile)


	def fltrSet = [BUNDLE_ID: newBundleId, APP_DESCRIPTION: PRODUCT_NAME]
	copyFile("application-descriptor.xml", tmpdir.getAbsolutePath(), "application-descriptor.xml",fltrSet)
	copyFile("Entitlements-Release.plist", tmpdir.getAbsolutePath(), "Entitlements-Release.plist", fltrSet)
	updateProjectSigner(tmpdir.getAbsolutePath())
		
	def props = new HashMap<String, String>()
	props.put('iOSSDK', IOS_SDK )//+ IOS_DEPLOYMENT_TARGET)
	props.put('SigningSetupiOS_Default', SIGNING_PROFILE_IOS)
	props.put('SigningSetupiOS', SIGNING_PROFILE_IOS)
	props.put('BundleID', newBundleId)
	def becreds = getSystemValue("BE_CREDENTIALS","")
	def beuser = ''
	def bepw = ''
	//System.out.println("becreds: ${becreds}")
	if (!"".equals(becreds)) {
		if (becreds.contains(':')) {
			beuser = becreds.split(':')[0]
			bepw = becreds.split(':')[1]
		}
	}
	if ("".equals(beuser) || "".equals(bepw)) {
		if ("".equals(beuser) && "".equals(bepw)) {
			ant.fail("You need to specify Build Envoy credentials to build with Build Envoy. Please supply them by running the" +
				" gradle script with the flags -DBE_CREDENTIALS")
		} else if ("".equal(beuser)) {
			ant.fail("You need to specify a Build Envoy user to build with Build Envoy. Please supply it by running the" +
				" gradle script with the flag -DBE_CREDENTIALS ")
		} else {
			ant.fail("You need to specify a Build Envoy credentials to build with Build Envoy. Please supply it by running the" +
				" gradle script with the flag -DBE_CREDENTIALS")
		}
	}
	props.put("IBMIntranetID", beuser)
	props.put("IBMIntranetPW", bepw)
	System.out.println("beuser: ${beuser}")
	props.put("AppCenter", APP_CENTER)
	props.put("APPDescription", APP_CENTER_DESCRIPTION)
	//System.out.println("bepw: ${bepw}")
	def beXcodeVersion = "Xcode.app"
	if(!"".equals(BE_XCODE_VERSION) && !"default".equals(BE_XCODE_VERSION)) {
		beXcodeVersion = "Xcode${BE_XCODE_VERSION}.app"
	}
	props.put("XcodeVersion", beXcodeVersion)

	//build the ipa in build envoy
	runAntTask(project, 'buildenvoy_iOS', props)
	//then download the built ipa from worklight app center which is where build envoy uploads it too.
	runAntTask(project, 'download_IOS', props)
	
	//After download, lets put them in "${buildDir}/binaries
	def bins = findFilesWithExtension('buildenvoy_temp', '.ipa', false)
	println ""
	println "************************************************************"
	for (def bin : bins) {
		copyFile(bin.getAbsolutePath(), ROOT_BUILD_DIR.getAbsolutePath() + "/binaries", bin.getName())
		println "Created signed .ipa file: " + ROOT_BUILD_DIR.getAbsolutePath() + "/binaries/" + bin.getName()
	}
	println "************************************************************"
}

void backupInfoPlistFile() {
	def currDir = getCurrentAbsolutePath()
	def infoPlist = findPlistInfoFile(currDir, PRODUCT_NAME, true)
	def infoFile = new File(infoPlist)
	println "infoPlist: " + infoPlist + ", curdir: " + currDir 
	if (!isEmptyOrNull(infoPlist) && infoFile.isFile()) {
		copyFile(infoPlist, infoFile.getParentFile().getAbsolutePath(), infoPlist + '.orig')
	}
}

void restoreInfoPlistFile() {
	def currDir = getCurrentAbsolutePath()
	def infoPlist = findPlistInfoFile(currDir, PRODUCT_NAME, true)
	def infoFile = new File(infoPlist)
	if (!isEmptyOrNull(infoPlist) && infoFile.isFile()) {
		copyFile(infoPlist + '.orig', infoFile.getParentFile().getAbsolutePath(), infoPlist)
	}
	delete (infoPlist + ".orig")
}

test.mustRunAfter(iosdebug)
setrelease.mustRunAfter(clean)
setdebug.mustRunAfter(clean)
test.mustRunAfter(settest)
settest.mustRunAfter(iosdebug)
instrumentstest.mustRunAfter(ocunittest)
ocunittest.mustRunAfter(settest)
hybridtest.mustRunAfter(instrumentstest)

task milhelp << {
	println ""
	println ""
	println "Usage:  gradle <iosrelease | iosdebug> [IOS_OPTIONS]"
	println ""
	println "   iosrelease      Task to build a signed .ipa file for iOS. "
	println "	                This requires you having setup the signing files on your machine"
	println "   iosdebug        Task to build a debug build for iOS.  "
	println "                   This creates a *.app directory that contains the compiled binaries"
	println ""
	println ""
	println "IOS_OPTIONS"
	println "   -DPRODUCT_NAME=<name>              Optional. Project name that you are building. For example: Ei!.  This will get used "
	println "                                      as part of the IPA file created. Current default is: " + PRODUCT_NAME
	println "   -DIOS_SDK=<sdk-name>               Optional. The target SDK to compile for. Examples are: iphoneos, iphoneos7.1. Current default is: " + IOS_SDK
	println "   -DXCODE_PROJECT=<.xcodeproj file>  Optional. The name of the xcode .xcodeproj file.  For example Ei!.xcodeproj. Current default is: " + XCODE_PROJECT
	println "   -DPROVISIONING_PROFILE=<file>      Optional. The fully qualified path to the provisioning profile that should be embedded "
	println "                                      in the .ipa file when a release build is executed. Current default is: " + PROVISIONING_PROFILE
	println "   -DCODE_SIGNER=<identity>           Optional. The name of the code signer (this is should be the name of an entry in the "
	println "                                      keychain access list) used to sign the code generated during a release build. Current default is: " + CODE_SIGNER
	println ""
	println ""
}
